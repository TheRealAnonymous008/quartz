# Pushdown Automata
* An extension of [[Finite Automata and Regular Languages|Finite Automata]] but with a special component called a **stack** that serves as additional (infinite) memory. We can push or pop symbols off of the stack.

* Formally, a (nondeterministic) **pushdown automata** is a $6$-tuple $(Q,\Sigma,\Gamma,\delta,q_0,F)$ where $Q,\Sigma,\Gamma$ and $F$ are all finite sets. We denote $\Sigma_\lambda = \Sigma\cup\lambda$ and $\Gamma_\lambda=\Gamma\cup\lambda$ 
	* $Q$ is the set of all states
	* $\Sigma$ is the input alphabet.
	* $\Gamma$ is the stack alphabet.
	* $\delta : Q \times \Sigma_{\lambda} \times \Gamma_\epsilon \to \mathcal{P}(Q\times \Gamma_\lambda)$ is the transition function.
	* $q_0\in Q$ is the start state.
	* $F\subseteq Q$ is the set of accept states.
* It accepts $\omega=w_1,\dots,w_m$ where each $w_i\in\Sigma_\lambda$ and the sequences of states $r_0,\dots,r_m\in Q$ and strings $s_0,\dots s_m\in \Gamma^\ast$ representing the stack contents that $M$ has on the accepting branch of the computation.
	1. $r_0=q_0, s_0=\lambda$. *Start on the start state with an empty stack*.
	2. For $i=0,\dots,m-1$ we have that $$(r_{i+1},b)\in\delta(r_i,w_{i+1},a)$$Where $s_i=at$ and $s_{i+1}=bt$ for $a,b\in \Gamma_\lambda$ and $t\in\Gamma^\ast$.  *Move properly according to state, stack, and next input*. That is, at state $r_i$, with $w_{i+1}$ at the top of the stack and popping symbol $a$, the next move is move to state $r_{i+1}$ and push symbol $b$.
	3. $r_m\in F$. *Accept state occurs at input end*.
* We may test for an empty stack by testing for a special delimiter $\$$. 
* We may test if the machine reaches the end of the input string  by assuming the accept state only takes effect when the machine is at the end of the input.

* *Sipser 2.20*: A Language is context free if and only if some PDA recognizes it. [^2]
[^2]: [[$Introduction to the Theory of Computation by Sipser|Sipser]] provides a proof. The idea is to establish an algorithm to convert from PDA to CFG and vice versa. This boils down to mapping states with nonterminals, and symbols (Including those pushed into the stack) with the terminals plus the nonterminals.
# Context Free Grammar
* A **context free grammar** is a $4$-tuple $(N,\Sigma, P,S)$ where the production rules are of the form $A\to (A\cup \Sigma)^\ast$, $A\in N$. 
* A CFG is in **Chomsky Normal Form** if every rule is of the form $$\begin{split} A &\to BC \\ A &\to a \end{split}$$
* *Sipser 2.9*: Any Context Free Language is generated by a CFG in Chomsky Normal Form. That is, we can convert any CFG into Chomsky Normal Form

# Non-Context Free Languages
* *Sipser 2.34*: **Pumping Lemma for CFLs** If $A$ is a CFL, then there is a number $p$ called the **pumping length** where if $s$ is any string in $A$ of length at least $p$, then $s$ may be divided into five pieces satisfying the following conditions: [^1]
1. $\forall i\ge 0$ $uv^ixy^iz\in A$ 
2. $|xy|>0$ and 
3. $|vxy|\le p$.

[^1]: Like the [[Finite Automata and Regular Languages#Nonregular Languages|Regular Language]] version, the pumping lemma holds because of the Pigeonhole Principle. The Pigeonhole Principle applies because every set in the Grammar is finite so we can simply use a string that is long enough such that in the parse tree, we have to use a production rule twice. Conditions 2 and 3 are there to make sure we don't have any pathologies when using the Pigeonhole Principle.

# Links
* [[$Introduction to the Theory of Computation by Sipser|Sipser Ch. 2]]